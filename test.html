<!DOCTYPE html>
<head>
<meta charset="utf-8">
<style>
  path {
    fill: #ccc;
    stroke: #fff;
    stroke-linejoin: round;
  }
  circle {
    opacity: .8;
  }
</style>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="http://d3js.org/queue.v1.min.js"></script>
</head>
<body>
<svg width="500" height="500"></svg>

<script>
  function getLocationData(){
    var q = d3.queue();
    for( i = 1; i<=14; i++){
      q.defer(d3.json, 'https://cors.io/?http://dublincitynoise.sonitussystems.com/applications/api/dublinnoisedata.php?location='+i); 
     }
     q.awaitAll(function(error, results){
       if(error) console.warn(error);
        console.log(results);
       for( i=1; i<=14; i++){
         locationData[i] = results[i-1];
       }
       drawMap();
     }
     );
   } 
  var width = 500;
  var height = 500;
  
  var chosenProjection = d3.geoMercator()
  .scale(18000)
  .translate([2230, 20100])
  var path = d3.geoPath()
  .projection(chosenProjection);

  //var b = path.bounds(),
  //    s = .95 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height),
  //        t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2];
         
  var coords;
  d3.json("coords.json", function(error, json) {
    if (error) return console.warn(error);
    coords = json;
    console.log(d3.entries(coords));
  });
  function drawMap(){

  d3.json("dublin.geojson", function(error, geoData) {
    if( error ) return console.error(error);
    
    d3.select("svg").append("path")
      .attr("d", path(geoData))
    
    d3.select("svg").selectAll("circle")
      .data(d3.entries(coords))
      .enter()
      .append("circle")
     // .attr("cx", function(d){return path(d)[0];})
     // .attr("cy", function(d){return path(d)[1];})
      .attr("transform", function(d) {
        return "translate(" + chosenProjection([
        d.value[1],
        d.value[0]
        ]) + ")";})                             
      .attr("r", function(d, i) { 
        console.log(i);
        console.log(d);
        console.log(d3.entries(locationData[i+1]));
        return d3.entries(locationData[i+1])[2].value[0]/10 +"px";})
      .attr("fill",function(d, i) { 
        return d3.interpolateReds(d3.entries(locationData[i+1])[2].value[0]/100) ;})
      .on("mouseover", stationMouseover)
      .on("mouseout", stationMouseout)
      //.text(function(d){return d.key;})
    });
  }

  function stationMouseover(d, i) {
    d3.select("svg")
      .append("text")
      .attr("id", function() { return "t" + d.key;})
      .attr(
        "transform", function(){return "translate("+chosenProjection([d.value[1],d.value[0]])+")";})
      .text(function(){
        return d.key;
      });
    }
   function stationMouseout(d, i) {
     d3.select("text").remove();
   }     
  
  var locationData = new Array(14);
  getLocationData(); 

    
</script>
</body>
